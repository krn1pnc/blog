---
title: 梦熊 2024 省选十三连测 做题记录
date: 2023-11-28 16:36:58
categories: 做题记录
---

## 11 月 21 日

### A. 树上填数

经过猜猜猜，发现最终方案肯定形如选定重心为根，某些子树内从上到下升，另外的子树内从上到下降．

将这些子树塞进背包里，根据经典结论，不同的物品只有 $O(\sqrt{n})$ 种，直接优化背包后枚举多少上升多少下降即可通过．

### * B. 序列化树

首先先将序列排序，首先 $1$ 肯定需要作为某个节点的父亲，故直接将其拿出一个．

然后考虑逐个为 $2 \sim n$ 分配父亲．为了让权值和最大，我们肯定要选序列中尽量小的元素当作他们的父亲，也就是将排序后的 $a_2 \sim a_n$ 作为 $p_2 \sim p_n$．此时可能会出现矛盾：如果有 $a_i > i$，肯定没救了，故只需考虑 $a_i = i$ 的情况．此时我们只能将其塞进 $1$ 到 $n$ 的链中．设这样的位置有 $x$ 个，$k < x$ 的情况均无解，剩下的情况贪心选边权即可．

### ! C. 两岸的猿

还没补．

## 11 月 28 日

### A. 道路

假设我们已经对于所有点对 $(u, v)$ 预处理出了最短路 $d_{u, v}$．对于边 $(u, v, w)$，限制可以被表述为存在一个 $(p, q, t)$，使得 $\min\{d_{p, u} + w + d_{v, q}, d_{p, v} + w + d_{u, q}\} \le t$．

那个 $\min$ 可以不管，将点对翻转后再做一遍即可．考虑对于每条边 $(u, v, w)$，如何快速判断对于所有 $(p, q, t)$，有 $d_{p, u} + w + d_{v, q} \le t$．将限制变形后可以得到 $w \le t - d_{p, u} - d_{v, q}$．不妨预处理 $f_{p, v}$ 代表对于所有 $(p, q, t)$，$\max\{t - d_{v, q}\}$，这样在判断时枚举 $p$，判定 $\max\{f_{p, v} - d_{p, u}\} \ge w$ 即可．

时间复杂度 $O(n^3)$．

### B. 颁奖

不妨在点 $u$ 下面挂个虚点 $u^\prime$，$u$ 到 $u^\prime$ 的边权是 $a_u$．然后我们发现，最终的点一定是加虚点后图的直径的中点．线段树维护直径，然后倍增跳一下即可．

### ! C. 红石灯

还没补．

## 12 月 5 日

### * A. 做题掉坑

令 $P(x)$ 表示第 $x$ 天掉进坑里的概率，$Q(x)$ 表示前 $x$ 天都没掉进坑里的概率，有 $P(x) = Q(x - 1) - Q(x)$．

答案由下式给出：

$$
\begin{aligned}
  \sum_{i = 1}^m iP(i)
  &= \sum_{i = 1}^m i(Q(i - 1) - Q(i)) \\
  &= \sum_{i = 1}^m iQ(i - 1) - \sum_{i = 1}^m iQ(i) \\
  &= \sum_{i = 0}^{m - 1} (i + 1)Q(i) - \sum_{i = 1}^m iQ(i) \\
  &= \sum_{i = 1}^{m - 1} (i + 1)Q(i) - \sum_{i = 1}^{m - 1} iQ(i) \\
  &= \sum_{i = 1}^{m - 1} Q(i)
\end{aligned}
$$

考虑求出 $Q(i)$．由于我们不能走到 $k$，故可以将 $k$ 转到最前面，然后环就变成链了．不妨令转完的位置分别为 $a_0, a_1, \cdots, a_{m - 1}$，然后再令 $a_m = n$．设 $f_{i, j}$ 表示 $[1, a_i)$ 这个区间内被随到了 $j$ 次的概率，转移枚举 $[a_{i - 1}, a_i)$ 这个区间被随到了多少次，有

$$
f_{i, j} \leftarrow f_{i - 1, j - k} \times \binom{k}{j} \times \left(\frac{a_i - a_{i - 1}}{n}\right)^k
$$

答案即为 $\sum\limits_{i < m} f_{m, i}$．

### * B. 攀比之心

打表可以发现，Bob 胜的充要条件是直径的中点过 $1$．

考虑对这样的连通块计数．不妨先计算出 $f_{u, i}$ 表示以 $u$ 为根的子树，最深的节点深度为 $i$ 的连通块的方案数，直径终点过 $1$ 的方案可以通过简单容斥得出．

转移考虑合并 $v$ 的子树：

$$
f_{u, i} = f_{u, i} \times \sum_{j + 1 \le i} f_{v, j} + f_{v, i - 1} \times \sum_{j + 1 \le i} f_{u, j}
$$

第二部分显然可以长剖优化，第一部分注意到 $i$ 大于 $v$ 子树内最大深度的部分的转移形如乘上一个常数，可以通过打标记解决，然后就 $O(n)$ 了．

注意长剖优化 DP 时，整个过程做完之后只有长链顶的 DP 数组是对的，而我们容斥需要用到 $1$ 的所有儿子的 DP 数组，故需先备份 $1$ 的长儿子的 DP 数组．

### ! C. 渡船开摆

还没补．

## 12 月 7 日

### ! A. 魔法树

正解暂时不会补，这里记录一下 80 分做法．

不妨称原图中原有的边为 1 边，原图中不存在的边为 0 边．容易发现，对于 $n$ 阶完全图的一个生成树，$T$ 次操作后得到它的概率只和其中的 1 边数量有关，这个可以简单递推实现．问题转化为计算包含恰好 $k$ 条 1 边的生成树个数．

有一个显然的做法是，令 1 边的边权为 $x$，0 边的边权为 $1$，然后跑矩阵树定理可以得到一个 $n - 1$ 次多项式 $F(x)$，显然恰好包含 $k$ 条 1 边的生成树个数为 $[x^k] F(x)$．然而我们不可能直接计算 $F(x)$，考虑一些数值方式！我们给 $x$ 随机带入 $n$ 个值，可以得到关于各项系数的 $n$ 个方程，直接解方程即可．

### * B. 排列

先建出树来，不妨令当前节点为 $p$，左右儿子分别为 $l$ 和 $r$．

若我们确定了 $a_p, a_l, a_r$ 的排列方式，左右子树就变成了独立的子问题，可以递归解决．考虑如何确定排列方式．

1. 若 $a_p$ 是最小值，无需进行任何交换．
1. 若 $a_l$ 是最小值，此时只能交换 $a_p$ 和 $a_l$．
1. 若 $a_r$ 是最小值，此时可以将 $a_p$ 和 $a_r$ 以任意顺序放在 $l$ 和 $r$ 上．

看起来很难办！但我们可以爆搜确定较小值放 $l$ 还是 $r$ 上能够排到序列中更靠前的位置．分析一下这个爆搜的状态数，每个节点可能要检查的值只可能来自其祖先链或兄弟节点，故总状态数 $O(n \log n)$．记忆化即可．

### ! C. 上升子序列

还没补．

## 12 月 12 日

### * A. 马吉克

若有两线段 $i$ 和 $j$ 满足 $l_i < l_j < r_i < r_j$，那么 $l_j$ 和 $r_i$ 就不能同时选．我们发现这些有交的区间限制了答案中某些点不能同时出现．这启发我们将满足上述条件的 $l_j$ 和 $r_i$ 建边，答案即为图中最大独立集大小．有注意到我们只有某些左端点到某些右端点的边，故这是一个二分图．

然而暴力建图有 $O(n^2)$ 条边，Dinic 跑不动，观察到将区间 $i$ 当作点对 $(l_i, r_i)$ 拍到平面上之后，建图的限制想到于一个 3-side 矩形．可持久化线段树优化建图即可．

### * B. 卡勒尔英

好像是某场 xcpc 的原，之前在 QOJ 上看到过．

先将边反向，操作变成沿着边传递颜色．反向后的图显然是一个外向基环树．树的部分是容易的，DP 一遍即可．具体地，设 $f_{u, i}$ 表示 $u$ 子树内，$u$ 被修改 $i$ 次的最大收益，转移显然．

现在考虑如何处理 $s$ 在环上的情况．发现环上点的修改次数相差不会超过 $2$，故可以枚举修改次数合并 DP 数组．注意特判环长 $\le 2$ 的情况，此时上述结论是错的．

### ! C. 睿克谈勾

好他妈难写．丢个 [原题链接](https://qoj.ac/problem/6304) 跑路了．

## 12 月 19 日

### A. 路径

令 $u$ 的父亲为 $\mathrm{fa}_u$，注意到若对权值做树上差分，令 $a_u \leftarrow a_{\mathrm{fa}_u} - a_u$，那么询问相当于求路径上的最大子段和，倍增即可．

一开始忽略了信息的可并性，弄出了个要历史最值的逆天做法．

### * B. 迷失

${A^k}_{u, v}$ 的含义是 $u \to v$ 是否存在长度为 $k$ 的路径．对于一个强连通分量，假设经过了足够长的时间，我们显然能够使用环内的任意一个环来增广我们的路径，故若原图强联通，$d$ 就是其中所有环长的 gcd．对于非强连通图，求得每个强连通分量的答案后取 lcm 即可．

然后就可以二分 $k$ 了．使用逐位确定答案的写法，时间复杂度 $O(n^3 \log V)$．注意到最后一个包不用求 $k$．/cf

### C. 树

垃圾．

要求子区间权值和，套上历史和，问题转化为对 $r$ 做扫描线时，对于所有 $l \le r$，维护出区间 $[l, r]$ 的权值．

权值可以分成两部分，第一部分是连通块到根的路径并的大小，这个可以通过经典的 lct 配合扫描线的技巧维护，更新是区间加的形式．第二部分是连通块构成虚树的根的深度，这部分要扣掉，用个类似单调栈维护所有 $l \le r$ 且区间 $[l, r]$ 的 lca 和区间 $[l + 1, r]$ 的 lca 不同的点，更新是区间覆盖的形式．

再写个支持区间加区间覆盖区间历史和的线段树即可．
