---
title: 梦熊 2024 省选十三连测 做题记录
date: 2023-11-28 16:36:58
categories: 做题记录
---

## 11 月 21 日

### A. 树上填数

经过猜猜猜，发现最终方案肯定形如选定重心为根，某些子树内从上到下升，另外的子树内从上到下降．

将这些子树塞进背包里，根据经典结论，不同的物品只有 $O(\sqrt{n})$ 种，直接优化背包后枚举多少上升多少下降即可通过．

### * B. 序列化树

首先先将序列排序，首先 $1$ 肯定需要作为某个节点的父亲，故直接将其拿出一个．

然后考虑逐个为 $2 \sim n$ 分配父亲．为了让权值和最大，我们肯定要选序列中尽量小的元素当作他们的父亲，也就是将排序后的 $a_2 \sim a_n$ 作为 $p_2 \sim p_n$．此时可能会出现矛盾：如果有 $a_i > i$，肯定没救了，故只需考虑 $a_i = i$ 的情况．此时我们只能将其塞进 $1$ 到 $n$ 的链中．设这样的位置有 $x$ 个，$k < x$ 的情况均无解，剩下的情况贪心选边权即可．

### ! C. 两岸的猿

还没补．

## 11 月 28 日

### A. 道路

假设我们已经对于所有点对 $(u, v)$ 预处理出了最短路 $d_{u, v}$．对于边 $(u, v, w)$，限制可以被表述为存在一个 $(p, q, t)$，使得 $\min\{d_{p, u} + w + d_{v, q}, d_{p, v} + w + d_{u, q}\} \le t$．

那个 $\min$ 可以不管，将点对翻转后再做一遍即可．考虑对于每条边 $(u, v, w)$，如何快速判断对于所有 $(p, q, t)$，有 $d_{p, u} + w + d_{v, q} \le t$．将限制变形后可以得到 $w \le t - d_{p, u} - d_{v, q}$．不妨预处理 $f_{p, v}$ 代表对于所有 $(p, q, t)$，$\max\{t - d_{v, q}\}$，这样在判断时枚举 $p$，判定 $\max\{f_{p, v} - d_{p, u}\} \ge w$ 即可．

时间复杂度 $O(n^3)$．

### B. 颁奖

不妨在点 $u$ 下面挂个虚点 $u^\prime$，$u$ 到 $u^\prime$ 的边权是 $a_u$．然后我们发现，最终的点一定是加虚点后图的直径的中点．线段树维护直径，然后倍增跳一下即可．

### ! C. 红石灯

还没补．

## 12 月 5 日

### * A. 做题掉坑

令 $P(x)$ 表示第 $x$ 天掉进坑里的概率，$Q(x)$ 表示前 $x$ 天都没掉进坑里的概率，有 $P(x) = Q(x - 1) - Q(x)$．

答案由下式给出：

$$
\begin{aligned}
  \sum_{i = 1}^m iP(i)
  &= \sum_{i = 1}^m i(Q(i - 1) - Q(i)) \\
  &= \sum_{i = 1}^m iQ(i - 1) - \sum_{i = 1}^m iQ(i) \\
  &= \sum_{i = 0}^{m - 1} (i + 1)Q(i) - \sum_{i = 1}^m iQ(i) \\
  &= \sum_{i = 1}^{m - 1} (i + 1)Q(i) - \sum_{i = 1}^{m - 1} iQ(i) \\
  &= \sum_{i = 1}^{m - 1} Q(i)
\end{aligned}
$$

考虑求出 $Q(i)$．由于我们不能走到 $k$，故可以将 $k$ 转到最前面，然后环就变成链了．不妨令转完的位置分别为 $a_0, a_1, \cdots, a_{m - 1}$，然后再令 $a_m = n$．设 $f_{i, j}$ 表示 $[1, a_i)$ 这个区间内被随到了 $j$ 次的概率，转移枚举 $[a_{i - 1}, a_i)$ 这个区间被随到了多少次，有

$$
f_{i, j} \leftarrow f_{i - 1, j - k} \times \binom{k}{j} \times \left(\frac{a_i - a_{i - 1}}{n}\right)^k
$$

答案即为 $\sum\limits_{i < m} f_{m, i}$．

### * B. 攀比之心

打表可以发现，Bob 胜的充要条件是直径的中点过 $1$．

考虑对这样的连通块计数．不妨先计算出 $f_{u, i}$ 表示以 $u$ 为根的子树，最深的节点深度为 $i$ 的连通块的方案数，直径终点过 $1$ 的方案可以通过简单容斥得出．

转移考虑合并 $v$ 的子树：

$$
f_{u, i} = f_{u, i} \times \sum_{j + 1 \le i} f_{v, j} + f_{v, i - 1} \times \sum_{j + 1 \le i} f_{u, j}
$$

第二部分显然可以长剖优化，第一部分注意到 $i$ 大于 $v$ 子树内最大深度的部分的转移形如乘上一个常数，可以通过打标记解决，然后就 $O(n)$ 了．

注意长剖优化 DP 时，整个过程做完之后只有长链顶的 DP 数组是对的，而我们容斥需要用到 $1$ 的所有儿子的 DP 数组，故需先备份 $1$ 的长儿子的 DP 数组．

### ! C. 渡船开摆

还没补．

## 12 月 7 日

### ! A. 魔法树

正解暂时不会补，这里记录一下 80 分做法．

不妨称原图中原有的边为 1 边，原图中不存在的边为 0 边．容易发现，对于 $n$ 阶完全图的一个生成树，$T$ 次操作后得到它的概率只和其中的 1 边数量有关，这个可以简单递推实现．问题转化为计算包含恰好 $k$ 条 1 边的生成树个数．

有一个显然的做法是，令 1 边的边权为 $x$，0 边的边权为 $1$，然后跑矩阵树定理可以得到一个 $n - 1$ 次多项式 $F(x)$，显然恰好包含 $k$ 条 1 边的生成树个数为 $[x^k] F(x)$．然而我们不可能直接计算 $F(x)$，考虑一些数值方式！我们给 $x$ 随机带入 $n$ 个值，可以得到关于各项系数的 $n$ 个方程，直接解方程即可．

### * B. 排列

先建出树来，不妨令当前节点为 $p$，左右儿子分别为 $l$ 和 $r$．

若我们确定了 $a_p, a_l, a_r$ 的排列方式，左右子树就变成了独立的子问题，可以递归解决．考虑如何确定排列方式．

1. 若 $a_p$ 是最小值，无需进行任何交换．
1. 若 $a_l$ 是最小值，此时只能交换 $a_p$ 和 $a_l$．
1. 若 $a_r$ 是最小值，此时可以将 $a_p$ 和 $a_r$ 以任意顺序放在 $l$ 和 $r$ 上．

看起来很难办！但我们可以爆搜确定较小值放 $l$ 还是 $r$ 上能够排到序列中更靠前的位置．分析一下这个爆搜的状态数，每个节点可能要检查的值只可能来自其祖先链或兄弟节点，故总状态数 $O(n \log n)$．记忆化即可．

### ! C. 上升子序列

还没补．

## 12 月 12 日

### * A. 马吉克

若有两线段 $i$ 和 $j$ 满足 $l_i < l_j < r_i < r_j$，那么 $l_j$ 和 $r_i$ 就不能同时选．我们发现这些有交的区间限制了答案中某些点不能同时出现．这启发我们将满足上述条件的 $l_j$ 和 $r_i$ 建边，答案即为图中最大独立集大小．有注意到我们只有某些左端点到某些右端点的边，故这是一个二分图．

然而暴力建图有 $O(n^2)$ 条边，Dinic 跑不动，观察到将区间 $i$ 当作点对 $(l_i, r_i)$ 拍到平面上之后，建图的限制想到于一个 3-side 矩形．可持久化线段树优化建图即可．

### * B. 卡勒尔英

好像是某场 xcpc 的原，之前在 QOJ 上看到过．

先将边反向，操作变成沿着边传递颜色．反向后的图显然是一个外向基环树．树的部分是容易的，DP 一遍即可．具体地，设 $f_{u, i}$ 表示 $u$ 子树内，$u$ 被修改 $i$ 次的最大收益，转移显然．

现在考虑如何处理 $s$ 在环上的情况．发现环上点的修改次数相差不会超过 $2$，故可以枚举修改次数合并 DP 数组．注意特判环长 $\le 2$ 的情况，此时上述结论是错的．

### ! C. 睿克谈勾

好他妈难写．丢个 [原题链接](https://qoj.ac/problem/6304) 跑路了．

## 12 月 19 日

### A. 路径

令 $u$ 的父亲为 $\mathrm{fa}_u$，注意到若对权值做树上差分，令 $a_u \leftarrow a_{\mathrm{fa}_u} - a_u$，那么询问相当于求路径上的最大子段和，倍增即可．

一开始忽略了信息的可并性，弄出了个要历史最值的逆天做法．

### * B. 迷失

${A^k}_{u, v}$ 的含义是 $u \to v$ 是否存在长度为 $k$ 的路径．对于一个强连通分量，假设经过了足够长的时间，我们显然能够使用环内的任意一个环来增广我们的路径，故若原图强联通，$d$ 就是其中所有环长的 gcd．对于非强连通图，求得每个强连通分量的答案后取 lcm 即可．

然后就可以二分 $k$ 了．使用逐位确定答案的写法，时间复杂度 $O(n^3 \log V)$．注意到最后一个包不用求 $k$．/cf

### C. 树

垃圾．

要求子区间权值和，套上历史和，问题转化为对 $r$ 做扫描线时，对于所有 $l \le r$，维护出区间 $[l, r]$ 的权值．

权值可以分成两部分，第一部分是连通块到根的路径并的大小，这个可以通过经典的 lct 配合扫描线的技巧维护，更新是区间加的形式．第二部分是连通块构成虚树的根的深度，这部分要扣掉，用个类似单调栈维护所有 $l \le r$ 且区间 $[l, r]$ 的 lca 和区间 $[l + 1, r]$ 的 lca 不同的点，更新是区间覆盖的形式．

再写个支持区间加区间覆盖区间历史和的线段树即可．

## 12 月 26 日

### A. 魔法宝石

分治即可．

### B. 商人

[A298637](https://oeis.org/A298637)．

### * C. 首都

先建圆方树，$u \to v$ 会被 $w$ 拦住当且仅当 $w$ 是必经点，即圆方树上 $u \to v$ 的路径经过 $w$．

然后进行一个贡献的拆，答案可写成如下形式

$$
nk - \min_r \left\{ \sum_u w_u \mathrm{dist}(u, r) \right\}
$$

其中 $\mathrm{dist}(u, v)$ 的含义是圆方树上 $u \to v$ 路径上的圆点数，含义是先让所有点都贡献，然后枚举首都 $r$，对于节点 $u$，防御工事选在 $u \to r$ 路径上的所有圆点都会导致贡献被减去一次．

考虑如何求后面那个 $\min$．通过观观观察察察可以发现，$r$ 只会选到关键点构成的虚树上．故考虑换根 DP 出每个点作为 $r$ 时 $\min$ 里的东西，然后分类讨论选在点上还是边上，对所有情况取 $\min$．注意 $r$ 不能选到方点上．

## 1 月 2 日

### * A. 景点游览

没做出来，鉴定为唐．

预处理 $\mathrm{mx}_i$ 表示 $i$ 能到的编号最大的点，$\mathrm{mn}_i$ 表示 $i$ 能到的编号最小的点．一个区间 $[l, r]$ 合法，当且仅当 $\forall i \in [l, r], l \le \mathrm{mn}_i, r \ge \mathrm{mx}_i$，容易分治统计．

### * B. 人生画卷

我草，申必双射题．

显然连续段没有用，故缩起来．然后不知道怎么就能发现缩完后有 $i$ 种颜色的序列和有 $i$ 个右儿子的二叉树能构成双射！具体而言，我们将序列中和最后一个位置的颜色相同的位置扒出来，当作一条左链，然后剩下的部分递归构造，挂到右侧的右儿子上．

然后 $n$ 个节点，$i$ 个右儿子的二叉树数目是 [A001263](https://oeis.org/A001263)．证明不会！那么答案由下式给出：

$$
\sum_i \frac{1}{i} \binom{n}{i - 1} \binom{n - 1}{i - 1} \times \binom{m}{i} i!
$$

### * C. 博弈游戏

有一个费用流建模就是，建立源点 $S$，汇点 $T$ 和 $n$ 个代表选取的数的点 $u_i$，建边 $(S, u_i, 1, a_i)$，$(u_i, u_{i + 1}, \infty, 0)$，$(u_i, T, 1, b_i)$，最小费用最大流即为答案．

显然直接建图跑寄了，由于费用流刻画的问题关于流量是凸的，故直接 wqs 二分，问题转化为求最小费用可行流．考虑加入 $u_i$ 新增的增广路对答案的影响．我们有如下三种增广路：

1. $S \to u_i \to T$，直接计算即可．
2. $S \to u_j \to \cdots \to u_i \to T$，即选某个未用过的 $a_j$，选取 $a_j$ 和 $b_i$．
3. $T \to u_j \to \cdots \to u_i \to T$，即选某个用过的 $b_j$，去掉 $b_j$ 选取 $b_i$．

用两个堆分别维护没用过的 $a_i$ 和用过的 $b_j$ 即可．

总复杂度 $O(n \log n \log V)$．

## 1 月 9 日

### * A. 序列

给我唐完了．

注意到任意一种操作序列都可以写成先加后除的形式．先枚举除的次数 $k$，若我们一开始加了 $c$，$c$ 的低 $k$ 位可以塞到某些除法后做，这部分代价是低 $k$ 位的 popcount；$c$ 的高位必须直接加，这部分代价是 $\lfloor c / 2^k \rfloor$．注意到关键的（即给全体加后会导致某个 $\lfloor (a_i + c) / 2^k \rfloor$ 加一的）低 $k$ 位数只有 $n$ 个，故考虑将高低位分开做．

从小到大枚举低 $k$ 位关键的值，记 ${a^\prime}_i$ 表示加了低 $k$ 位后 $a_i$ 的取值，显然只可能是 $\lfloor a_i / 2^k \rfloor$ 和 $\lfloor a_i / 2^k \rfloor + 1$，且枚举的过程中改变量是 $O(n)$ 的．考虑 $c$ 高位取 $x$ 时，最后这一部分代价就是 $x + \sum |{a^\prime}_i + x - b_i|$，显然取序列 $\{b_i - {a^\prime}_i\}$ 的中位数最优．注意到每次改变 $a^\prime$ 只会给这个序列中的某些元素减 $1$，且每个元素最多减去一次，故可能取的值只有原本的中位数及其减 $1$，弄两个树状数组就能算了．

还有一个要最小化的量是一段区间 $[l, r]$ 内的 popcount 最小值，这个分讨是否包含某个 $2^k$ 和去除 $l$ 和 $r$ 的二进制 lcp 后 $l$ 是否全 $0$ 即可．

### ! B. 梦

还没补．

### * C. 夏虫

设 $f_i$ 表示有多少个 $x$ 满足 $c$ 是区间 $[1, i - 1]$ 的某个后缀最值或 $[i + 1, n]$ 的某个前缀最值．问题转化为支持交换相邻元素，对区间的 $f$ 求和．

先考虑如何计算出原序列的 $f$，对于 $a_i$，设 $L_i$ 表示最大的 $j$ 满足 $j < i, a_j > a_i$，$R_i$ 表示最小的 $j$ 满足 $j > i, a_j > a_i$．不妨令 $a_{L_i} < a_{R_i}$，那么有 $f_i = f_{L_i} + 1$，其他情况类似．

考虑交换 $a_x$ 和 $a_{x + 1}$ 对 $f$ 造成的影响．对于 $i < x$，若 $\max\limits_{j = i}^{x - 1} a_j < a_x$，那么交换后 $f_i$ 会减 $1$，$i > x$ 的情况类似，可以用线段树维护区间加．再维护一个 $a$ 的最值即可在线段树上二分找到目标区间．$x$ 和 $x + 1$ 位置重算即可．
